# InventoryTracer

InventoryTracer was designed to help users track items and quantities in a simple, mobile-friendly format. The goal was to create a clean, functional app that supports basic inventory management without overwhelming the user. This app addresses the need for quick item logging, especially for small businesses, students, or anyone managing supplies or collections.
To support user needs, I built two core screens: a launch screen that displays existing inventory and a form screen for adding new items. The UI was designed with clarity in mind—spaced elements, readable fonts, and a minimal layout that avoids clutter. I used hardcoded sample data during design to validate spacing and alignment, then switched to dynamic content for final submission. The design was successful because it kept the user focused on one task at a time and provided immediate visual feedback.
My coding approach was iterative and resilient. I rebuilt the app from scratch after encountering build errors, manually recreated missing configuration files, and validated each feature step-by-step. I used Android Studio’s emulator to test functionality, confirmed database operations, and wrapped risky logic in try/catch blocks to prevent crashes. These strategies helped me stay aligned with rubric requirements and will be useful in future projects where debugging and documentation are key.
Testing was critical. I confirmed that the app launched cleanly, that sample data displayed correctly, and that form submissions updated the database. This process revealed how fragile build configurations can be and reinforced the importance of validating each component independently before integration.
One challenge I had to innovate around was outdated instructions and missing files. I adapted by researching current Android Studio tooling, benchmarking against successful GitHub student projects, and documenting every fix. This helped me stay on track and build a clean, working app.
The component I’m most proud of is the database integration. I was able to create a working shell, insert sample data, and connect it to the UI in a way that felt seamless. It demonstrated my ability to combine backend logic with user-centered design and troubleshoot across multiple layers of the app.
